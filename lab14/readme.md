# Домашнее задание №14
### Задание 1
> Ваша задача реализовать класс Task имеющий один метод get():

```java
public class Task<T> {
    public Task(Callable<? extends T> callable) {

    }

    public T get() {
        
    }
}
```
> Данный класс в конструкторе принимает экземпляр java.util.concurrent.Callable. Callable похож на Runnable, но результатом его работы является объект (а не void).
> Ваша задача реализовать метод get() который возвращает результат работы Callable. Выполнение callable должен начинать тот поток, который первый вызвал метод get(). Если несколько потоков одновременно вызывают этот метод, то выполнение должно начаться только в одном потоке, а остальные должны ожидать конца выполнения (не нагружая процессор).
> Если при вызове get() результат уже просчитан, то он должен вернуться сразу, (даже без задержек на вход в синхронизированную область).
> Если при просчете результата произошел Exception, то всем потокам при вызове get(), надо кидать этот Exception, обернутый в ваш RuntimeException (подходящее название своему ексепшену придумайте сами).

### Задание 2
> Ваша задача реализовать интерфейс ExecutionManager
```java
public interface ExecutionManager {
    Context execute(Runnable callback, Runnable... tasks);
}
```
> Метод execute принимает массив тасков, это задания которые ExecutionManager должен выполнять параллельно (в вашей реализации пусть будет в своем пуле потоков). После завершения всех тасков должен выполниться callback (ровно 1 раз). 
> Метод execute – это неблокирующий метод, который сразу возвращает объект Context. Context это интерфейс следующего вида:
```java
public interface Context {
    int getCompletedTaskCount();
    int getFailedTaskCount();
    int getInterruptedTaskCount();
    void interrupt();
    boolean isFinished();
}
```
> Метод getCompletedTaskCount() возвращает количество тасков, которые на текущий момент успешно выполнились.
> Метод getFailedTaskCount() возвращает количество тасков, при выполнении которых произошел Exception.
> Метод interrupt() отменяет выполнения тасков, которые еще не начали выполняться.
> Метод getInterruptedTaskCount() возвращает количество тасков, которые не были выполены из-за отмены (вызовом предыдущего метода).
> Метод isFinished() вернет true, если все таски были выполнены или отменены, false в противном случае.  


### Реализация
* Оба задания реализованы
* Написаны тесты
* Каждый тест проверяется несколько сотен раз (@RepeatedTest)
* В местах кода, требующем внимания оставлены комментарии

Задание 1
* Применена volatile переменная и DCL
Задание 2
* DCL, volatile с happens-before и atomic-типы